# js 根据 id、pid 把数据转化为树结构

```js
function buildTree(data) {
var root = []; // 初始化根节点
for (var i = 0; i < data.length; i++) {
var item = data[i];
if (!item.pid) { // 若无父节点 ID，则直接添加到根节点
root.push(item);
} else {
addToParentNode(root, item); // 向父节点添加子节点
}
}
return root;
}

// 向父节点添加子节点函数

function addToParentNode(parentNodes, childItem) {
for (var j = 0; j < parentNodes.length; j++) {
var node = parentNodes[j];
if (node.id === childItem.pid) { // 找到目标父节点
if (!node.children) {
node.children = []; // 若未设置子节点属性，则先初始化为空数组
}
node.children.push(childItem); // 将子节点添加到父节点的 children 属性中
break;
} else if (node.children && Array.isArray(node.children)) {
addToParentNode(node.children, childItem); // 递归调用自身，继续向下查找
}
}
}

// 测试数据

var data = [
{ id: 1, name: 'A', pid: null },
{ id: 8, name: 'H', pid: 1 },
{ id: 2, name: 'B', pid: 1 },
{ id: 3, name: 'C', pid: 1 },
{ id: 4, name: 'D', pid: 2 },
{ id: 5, name: 'E', pid: 2 },
{ id: 6, name: 'F', pid: 3 },
{ id: 7, name: 'G', pid: 3 }
];

function arrayToTree(arr) {
let map = {}; // 用于存放节点对象的字典
arr.forEach((item) => {
item['children'] = []; // 初始化每个节点的子节点列表
if (!map[item.id]) {
map[item.id] = item; // 将当前节点添加到字典中
} else {
Object.assign(map[item.id], item); // 如果已经有相同ID的节点，则合并属性值
}
});

const roots = []; // 根节点集合
for (let key in map) {
const node = map[key];
if (node.pid === null || !map[node.pid]) {
roots.push(node); // 没有指定父节点或者父节点不在字典中时，认为该节点为根节点
} else {
map[node.pid].children.push(node); // 否则将其作为父节点的子节点
}
}
return roots;
}

console.log(JSON.stringify(buildTree(data)));

console.log(JSON.stringify(arrayToTree(data)));
```